<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Matrix Representations · OperatorAlgebra.jl</title><meta name="title" content="Matrix Representations · OperatorAlgebra.jl"/><meta property="og:title" content="Matrix Representations · OperatorAlgebra.jl"/><meta property="twitter:title" content="Matrix Representations · OperatorAlgebra.jl"/><meta name="description" content="Documentation for OperatorAlgebra.jl."/><meta property="og:description" content="Documentation for OperatorAlgebra.jl."/><meta property="twitter:description" content="Documentation for OperatorAlgebra.jl."/><meta property="og:url" content="https://h-mnzlr.github.io/OperatorAlgebra.jl/guide/matrix_representation/"/><meta property="twitter:url" content="https://h-mnzlr.github.io/OperatorAlgebra.jl/guide/matrix_representation/"/><link rel="canonical" href="https://h-mnzlr.github.io/OperatorAlgebra.jl/guide/matrix_representation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">OperatorAlgebra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../operators/">Operator Types</a></li><li class="is-active"><a class="tocitem" href>Matrix Representations</a><ul class="internal"><li><a class="tocitem" href="#Cast-operators-into-matrix-representation"><span>Cast operators into matrix representation</span></a></li><li><a class="tocitem" href="#Matrix-Representations"><span>Matrix Representations</span></a></li><li><a class="tocitem" href="#Working-with-Product-States"><span>Working with Product States</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../api/types/">Types</a></li><li><a class="tocitem" href="../../api/operations/">Operations</a></li><li><a class="tocitem" href="../../api/constants/">Constants</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Matrix Representations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Matrix Representations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/h-mnzlr/OperatorAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="github.com/h-mnzlr/OperatorAlgebra.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Matrix-Representation-of-Operators"><a class="docs-heading-anchor" href="#Matrix-Representation-of-Operators">Matrix Representation of Operators</a><a id="Matrix-Representation-of-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Representation-of-Operators" title="Permalink"></a></h1><p>OperatorAlgebra.jl also exposes some of its functionality to cast operators into matrix representations using Kronecker products. In particular, the <code>atsite</code> function is useful to extend single-site operators to the full Hilbert space.</p><h2 id="Cast-operators-into-matrix-representation"><a class="docs-heading-anchor" href="#Cast-operators-into-matrix-representation">Cast operators into matrix representation</a><a id="Cast-operators-into-matrix-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Cast-operators-into-matrix-representation" title="Permalink"></a></h2><p>The <code>atsite</code> function casts a single-site operator into its matrix representation. By definition, a single-site operator acts non-trivially only on one site in a tensor product space, and as identity on all other sites.</p><h3 id="Basic-atsite"><a class="docs-heading-anchor" href="#Basic-atsite">Basic atsite</a><a id="Basic-atsite-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-atsite" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Define a 3-site system
basis = [1, 2, 3]

# Pauli X on site 2
σx = Op(PAULI_X, 2)

# Extend to full space: I ⊗ σx ⊗ I
σx_full = atsite(σx, basis)
# Result is an 8×8 matrix</code></pre><h3 id="With-Transformations"><a class="docs-heading-anchor" href="#With-Transformations">With Transformations</a><a id="With-Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#With-Transformations" title="Permalink"></a></h3><p>You can apply a transformation function (like <code>sparse</code>). This allows you to, e.g., efficiently allocate a sparse matrix representation directly. To make the tool flexible, arbitrary functions can be provided. The function is applied to the matrix object of the operator (<code>op.mat</code>).</p><pre><code class="language-julia hljs"># Convert to sparse in the process: I ⊗ sparse(σx) ⊗ I
σx_sparse = atsite(sparse, σx, basis)

# Custom transformation: I ⊗ f(σx) ⊗ I
f(x) = 2.0 * x
σx_scaled = atsite(f, σx, basis)</code></pre><h3 id="Variable-Dimensions"><a class="docs-heading-anchor" href="#Variable-Dimensions">Variable Dimensions</a><a id="Variable-Dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Dimensions" title="Permalink"></a></h3><p>Sometimes, it is necessary to work with local Hilbert spaces of different dimensions at different sites. In such cases, the local dimensions have to be specified as an additional argument to <code>atsite</code>. Passing an arbitrary transformation is still allowed to hook into the expansion process.</p><pre><code class="language-julia hljs"># Site 1: dimension 2, Site 2: dimension 3, Site 3: dimension 2
dims = [2, 3, 2]
basis = [1, 2, 3]

# Create a 3×3 operator for site 2
op_3x3 = Op(rand(3, 3), 2)

# Extend with correct dimensions
op_full = atsite(op_3x3, basis, dims)
# Result is 12×12 (2 × 3 × 2)</code></pre><p>For completeness, the <code>atsite</code> functionality can also be used to extend operators that act on multiple sites, e.g., an <code>OpChain</code> or <code>OpSum</code> operator. In this case, the operator is simply extended as a whole to the full Hilbert space. Ususally, this feature is not recommended, as there are usually more optimized ways to construct such operators directly in the full space for a given matrix type, e.g., for sparse matrices.</p><h2 id="Matrix-Representations"><a class="docs-heading-anchor" href="#Matrix-Representations">Matrix Representations</a><a id="Matrix-Representations-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Representations" title="Permalink"></a></h2><p>The main goal of this package is to create and manipulate operators algebraically before converting them to matrix representations. Depending on the system size and computational needs, different matrix representations should be chosen.</p><h3 id="Dense-Matrices"><a class="docs-heading-anchor" href="#Dense-Matrices">Dense Matrices</a><a id="Dense-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Dense-Matrices" title="Permalink"></a></h3><pre><code class="language-julia hljs">basis = 1:8

# Single operator
σx = Op(PAULI_X, 4)
σx_matrix = Array(σx, basis)

# Hamiltonian
H = sum(Op(PAULI_X, i) * Op(PAULI_X, i+1) for i in 1:7)
H_matrix = Array(H, basis)</code></pre><h3 id="Sparse-Matrices"><a class="docs-heading-anchor" href="#Sparse-Matrices">Sparse Matrices</a><a id="Sparse-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Matrices" title="Permalink"></a></h3><pre><code class="language-julia hljs">using SparseArrays
basis = 1:12

# Hamiltonian
H = sum(Op(PAULI_X, i) * Op(PAULI_X, i+1) for i in 1:11)
H_matrix = sparse(H, basis)</code></pre><h3 id="LinearMaps"><a class="docs-heading-anchor" href="#LinearMaps">LinearMaps</a><a id="LinearMaps-1"></a><a class="docs-heading-anchor-permalink" href="#LinearMaps" title="Permalink"></a></h3><pre><code class="language-julia hljs">using LinearMaps
basis = 1:20  # 2^20 ≈ 1 million dimensional space

H = sum(Op(PAULI_X, i) * Op(PAULI_X, i+1) for i in 1:19)
H_lm = LinearMap(H, basis)

# Matrix-vector multiplication
v = normalize!(rand(2^20))
result = H_lm * v</code></pre><h2 id="Working-with-Product-States"><a class="docs-heading-anchor" href="#Working-with-Product-States">Working with Product States</a><a id="Working-with-Product-States-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Product-States" title="Permalink"></a></h2><p>In some cases, it can be useful to work with product states directly without allocating on the full Hilbert space. For this, we provide limited funcionality to represent and manipulate product states via the <code>apply</code> function. Product states are represented as vectors of local state vectors, one for each site and applying and operator to this state is exactly applying the saved matrix of an operator to the local vector at the corresponding site. Hence, when using non-integer site identifiers, the order of basis elements has to be provided to <code>apply</code> to ensure correct mapping between site identifiers and local state vectors. Note, there are also corresponding in-place versions of <code>apply</code> provided, called <code>apply!</code>, to allow for efficient implementations.</p><h3 id="Representing-States"><a class="docs-heading-anchor" href="#Representing-States">Representing States</a><a id="Representing-States-1"></a><a class="docs-heading-anchor-permalink" href="#Representing-States" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Three-site system, each site is a 2-level system
state = [
    [1.0, 0.0],  # site 1
    [1.0, 0.0],  # site 2
    [0.0, 1.0]   # site 3
]

# Non-mutating
new_state = apply(Op(PAULI_X, 1), state)

# Mutating (more efficient)
apply!(Op(PAULI_X, 1), state)

# OpChain applies operators in sequence
chain = Op(PAULI_X, 1) * Op(PAULI_Z, 2)
result = apply(chain, state)

# generic site identifiers
apply(Op(PAULI_X, :site1), state, [:site1, :site2, :site3])</code></pre><p><code>apply</code> only works for operations that preserve the product state structure. This means that sums of operators cannot be applied directly, as they generally create entanglement between sites and thus destroy the product state structure.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../operators/">« Operator Types</a><a class="docs-footer-nextpage" href="../../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Tuesday 28 October 2025 13:18">Tuesday 28 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
