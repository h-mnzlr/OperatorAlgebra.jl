var documenterSearchIndex = {"docs":
[{"location":"api/constants/#Constants-Reference","page":"Constants","title":"Constants Reference","text":"","category":"section"},{"location":"api/constants/#Pauli-Matrices","page":"Constants","title":"Pauli Matrices","text":"","category":"section"},{"location":"api/constants/#OperatorAlgebra.PAULI_X","page":"Constants","title":"OperatorAlgebra.PAULI_X","text":"PAULI_X\n\nSparse Pauli X (σₓ) matrix: [[0, 1], [1, 0]]\n\nThe bit-flip operator. Exchanges |0⟩ ↔ |1⟩.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/#OperatorAlgebra.PAULI_Y","page":"Constants","title":"OperatorAlgebra.PAULI_Y","text":"PAULI_Y\n\nSparse Pauli Y (σᵧ) matrix: [[0, -i], [i, 0]]\n\nThe phase-flip and bit-flip operator.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/#OperatorAlgebra.PAULI_Z","page":"Constants","title":"OperatorAlgebra.PAULI_Z","text":"PAULI_Z\n\nSparse Pauli Z (σᵧ) matrix: [[1, 0], [0, -1]]\n\nThe phase-flip operator. Maps |0⟩ → |0⟩, |1⟩ → -|1⟩.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/#Fermionic-Operators","page":"Constants","title":"Fermionic Operators","text":"","category":"section"},{"location":"api/constants/#OperatorAlgebra.RAISE","page":"Constants","title":"OperatorAlgebra.RAISE","text":"RAISE\n\nSparse raising (creation) operator: [[0, 1], [0, 0]]\n\nMaps |0⟩ → |1⟩, |1⟩ → 0. Also called σ₊ or a†.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/#OperatorAlgebra.LOWER","page":"Constants","title":"OperatorAlgebra.LOWER","text":"LOWER\n\nSparse lowering (annihilation) operator: [[0, 0], [1, 0]]\n\nMaps |1⟩ → |0⟩, |0⟩ → 0. Also called σ₋ or a.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/#Occupation-Operators","page":"Constants","title":"Occupation Operators","text":"","category":"section"},{"location":"api/constants/#OperatorAlgebra.OCC_PART","page":"Constants","title":"OperatorAlgebra.OCC_PART","text":"OCC_PART\n\nSparse occupation number operator for particles: [[1, 0], [0, 0]]\n\nProjects onto the occupied state |1⟩.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/#OperatorAlgebra.OCC_HOLE","page":"Constants","title":"OperatorAlgebra.OCC_HOLE","text":"OCC_HOLE\n\nSparse occupation number operator for holes: [[0, 0], [0, 1]]\n\nProjects onto the empty state |0⟩.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/#Index","page":"Constants","title":"Index","text":"","category":"section"},{"location":"api/constants/","page":"Constants","title":"Constants","text":"Pages = [\"constants.md\"]","category":"page"},{"location":"api/types/#Type-Reference","page":"Types","title":"Type Reference","text":"","category":"section"},{"location":"api/types/#Abstract-Types","page":"Types","title":"Abstract Types","text":"","category":"section"},{"location":"api/types/#OperatorAlgebra.AbstractOp","page":"Types","title":"OperatorAlgebra.AbstractOp","text":"AbstractOp{Tid,Tmat}\n\nAbstract base type for all operator types in OperatorAlgebra.\n\nType Parameters\n\nTid: Type of site identifiers (e.g., Int, String)\nTmat: Element type of the underlying matrix representation\n\nSubtypes\n\nOp: Single-site operator\nOpChain: Product of operators\nOpSum: Sum of operators\n\nSee also: Op, OpChain, OpSum\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Concrete-Types","page":"Types","title":"Concrete Types","text":"","category":"section"},{"location":"api/types/#Op","page":"Types","title":"Op","text":"","category":"section"},{"location":"api/types/#OperatorAlgebra.Op","page":"Types","title":"OperatorAlgebra.Op","text":"Op{Tid,Tmat} <: AbstractOp{Tid,Tmat}\n\nA single-site operator acting on a specific site in a tensor product space.\n\nFields\n\nmat::AbstractMatrix{Tmat}: The matrix representation of the operator\nsite::Tid: The site identifier where the operator acts\n\nType Parameters\n\nTid: Type of site identifiers\nTmat: Element type of the matrix\n\nConstructors\n\nOp(mat::AbstractMatrix, site)\n\nCreate a single-site operator with matrix mat acting on site.\n\nExamples\n\n# Create Pauli X operator on site 1\nσx = Op(PAULI_X, 1)\n\n# Create a custom operator on site \"A\"\ncustom_op = Op([1.0 0.0; 0.0 -1.0], \"A\")\n\nOperations\n\nScalar multiplication: 2.0 * op, op * 2.0\nAdjoint: op'\nMultiplication with other operators: op1 * op2 (creates OpChain or merges if same site)\nAddition with other operators: op1 + op2 (creates OpSum or merges if same site)\n\nSee also: OpChain, OpSum, apply, atsite\n\n\n\n\n\n","category":"type"},{"location":"api/types/#OpChain","page":"Types","title":"OpChain","text":"","category":"section"},{"location":"api/types/#OperatorAlgebra.OpChain","page":"Types","title":"OperatorAlgebra.OpChain","text":"OpChain{Tid,Tmat} <: AbstractOp{Tid,Tmat}\n\nA product (chain) of operators representing non-commutative multiplication.\n\nAn OpChain is created automatically when multiplying operators together. It represents the product O₁ × O₂ × ... × Oₙ, where the order matters for non-commuting operators.\n\nFields\n\nops::Vector{<:AbstractOp{Tid,Tmat}}: Vector of operators in the product\n\nType Parameters\n\nTid: Type of site identifiers (automatically promoted)\nTmat: Element type of matrices (automatically promoted)\n\nConstructors\n\nOpChain(ops::Vararg{AbstractOp})\n\nCreate an operator chain from multiple operators. Types are automatically promoted.\n\nExamples\n\n# Create a chain by multiplication\nσx = Op(PAULI_X, 1)\nσy = Op(PAULI_Y, 2)\nσz = Op(PAULI_Z, 3)\nchain = σx * σy * σz  # Creates OpChain automatically\n\n# Operators on the same site are merged\nop1 = Op([1 0; 0 2], 1)\nop2 = Op([2 0; 0 1], 1)\nmerged = op1 * op2  # Single Op with matrix multiplication\n\n# Adjoint reverses order\nchain' == σz' * σy' * σx'  # true\n\nOperations\n\nScalar multiplication: 2.0 * chain, chain * 2.0\nAdjoint: chain' (reverses order and takes adjoint of each operator)\nMultiplication: Extends the chain\n\nSee also: Op, OpSum, apply, sparse\n\n\n\n\n\n","category":"type"},{"location":"api/types/#OpSum","page":"Types","title":"OpSum","text":"","category":"section"},{"location":"api/types/#OperatorAlgebra.OpSum","page":"Types","title":"OperatorAlgebra.OpSum","text":"OpSum{Tid,Tmat} <: AbstractOp{Tid,Tmat}\n\nA sum of operators representing linear combinations.\n\nAn OpSum is created automatically when adding operators together. It represents the sum O₁ + O₂ + ... + Oₙ.\n\nFields\n\nops::Vector{<:AbstractOp{Tid,Tmat}}: Vector of operators in the sum\n\nType Parameters\n\nTid: Type of site identifiers (automatically promoted)\nTmat: Element type of matrices (automatically promoted)\n\nConstructors\n\nOpSum(ops::Vararg{AbstractOp})\n\nCreate an operator sum from multiple operators. Types are automatically promoted.\n\nExamples\n\n# Create a sum by addition\nσx = Op(PAULI_X, 1)\nσz = Op(PAULI_Z, 2)\nH = σx + σz  # Creates OpSum automatically\n\n# Operators on the same site are merged\nop1 = Op([1 0; 0 0], 1)\nop2 = Op([0 0; 0 1], 1)\nmerged = op1 + op2  # Single Op with matrix addition\n\n# Build a Hamiltonian\nH = sum(Op(PAULI_X, i) for i in 1:5)  # OpSum of X operators\n\n# Scalar multiplication\nH_scaled = 2.0 * H  # Scales all terms\n\nNotes\n\napply and apply! are not defined for OpSum on product states, as the result is generally not a product state. Convert to a matrix representation first using sparse or LinearMap.\n\nSee also: Op, OpChain, sparse, LinearMap\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Type-Functions","page":"Types","title":"Type Functions","text":"","category":"section"},{"location":"api/types/#Base.eltype-Tuple{AbstractOp}","page":"Types","title":"Base.eltype","text":"eltype(op::AbstractOp)\n\nReturn the element type of the operator's matrix representation.\n\n\n\n\n\n","category":"method"},{"location":"api/types/#OperatorAlgebra.sitetype","page":"Types","title":"OperatorAlgebra.sitetype","text":"sitetype(op::AbstractOp)\n\nReturn the type used for site identifiers in the operator.\n\n\n\n\n\n","category":"function"},{"location":"guide/matrix_representation/#Matrix-Representation-of-Operators","page":"Matrix Representations","title":"Matrix Representation of Operators","text":"","category":"section"},{"location":"guide/matrix_representation/","page":"Matrix Representations","title":"Matrix Representations","text":"OperatorAlgebra.jl also exposes some of its functionality to cast operators into matrix representations using Kronecker products. In particular, the atsite function is useful to extend single-site operators to the full Hilbert space.","category":"page"},{"location":"guide/matrix_representation/#Cast-operators-into-matrix-representation","page":"Matrix Representations","title":"Cast operators into matrix representation","text":"","category":"section"},{"location":"guide/matrix_representation/","page":"Matrix Representations","title":"Matrix Representations","text":"The atsite function casts a single-site operator into its matrix representation. By definition, a single-site operator acts non-trivially only on one site in a tensor product space, and as identity on all other sites.","category":"page"},{"location":"guide/matrix_representation/#Basic-atsite","page":"Matrix Representations","title":"Basic atsite","text":"","category":"section"},{"location":"guide/matrix_representation/","page":"Matrix Representations","title":"Matrix Representations","text":"# Define a 3-site system\nbasis = [1, 2, 3]\n\n# Pauli X on site 2\nσx = Op(PAULI_X, 2)\n\n# Extend to full space: I ⊗ σx ⊗ I\nσx_full = atsite(σx, basis)\n# Result is an 8×8 matrix","category":"page"},{"location":"guide/matrix_representation/#With-Transformations","page":"Matrix Representations","title":"With Transformations","text":"","category":"section"},{"location":"guide/matrix_representation/","page":"Matrix Representations","title":"Matrix Representations","text":"You can apply a transformation function (like sparse). This allows you to, e.g., efficiently allocate a sparse matrix representation directly. To make the tool flexible, arbitrary functions can be provided. The function is applied to the matrix object of the operator (op.mat).","category":"page"},{"location":"guide/matrix_representation/","page":"Matrix Representations","title":"Matrix Representations","text":"# Convert to sparse in the process: I ⊗ sparse(σx) ⊗ I\nσx_sparse = atsite(sparse, σx, basis)\n\n# Custom transformation: I ⊗ f(σx) ⊗ I\nf(x) = 2.0 * x\nσx_scaled = atsite(f, σx, basis)","category":"page"},{"location":"guide/matrix_representation/#Variable-Dimensions","page":"Matrix Representations","title":"Variable Dimensions","text":"","category":"section"},{"location":"guide/matrix_representation/","page":"Matrix Representations","title":"Matrix Representations","text":"Sometimes, it is necessary to work with local Hilbert spaces of different dimensions at different sites. In such cases, the local dimensions have to be specified as an additional argument to atsite. Passing an arbitrary transformation is still allowed to hook into the expansion process.","category":"page"},{"location":"guide/matrix_representation/","page":"Matrix Representations","title":"Matrix Representations","text":"# Site 1: dimension 2, Site 2: dimension 3, Site 3: dimension 2\ndims = [2, 3, 2]\nbasis = [1, 2, 3]\n\n# Create a 3×3 operator for site 2\nop_3x3 = Op(rand(3, 3), 2)\n\n# Extend with correct dimensions\nop_full = atsite(op_3x3, basis, dims)\n# Result is 12×12 (2 × 3 × 2)","category":"page"},{"location":"guide/matrix_representation/","page":"Matrix Representations","title":"Matrix Representations","text":"For completeness, the atsite functionality can also be used to extend operators that act on multiple sites, e.g., an OpChain or OpSum operator. In this case, the operator is simply extended as a whole to the full Hilbert space. Ususally, this feature is not recommended, as there are usually more optimized ways to construct such operators directly in the full space for a given matrix type, e.g., for sparse matrices.","category":"page"},{"location":"guide/matrix_representation/#Matrix-Representations","page":"Matrix Representations","title":"Matrix Representations","text":"","category":"section"},{"location":"guide/matrix_representation/","page":"Matrix Representations","title":"Matrix Representations","text":"The main goal of this package is to create and manipulate operators algebraically before converting them to matrix representations. Depending on the system size and computational needs, different matrix representations should be chosen.","category":"page"},{"location":"guide/matrix_representation/#Dense-Matrices","page":"Matrix Representations","title":"Dense Matrices","text":"","category":"section"},{"location":"guide/matrix_representation/","page":"Matrix Representations","title":"Matrix Representations","text":"basis = 1:8\n\n# Single operator\nσx = Op(PAULI_X, 4)\nσx_matrix = Array(σx, basis)\n\n# Hamiltonian\nH = sum(Op(PAULI_X, i) * Op(PAULI_X, i+1) for i in 1:7)\nH_matrix = Array(H, basis)","category":"page"},{"location":"guide/matrix_representation/#Sparse-Matrices","page":"Matrix Representations","title":"Sparse Matrices","text":"","category":"section"},{"location":"guide/matrix_representation/","page":"Matrix Representations","title":"Matrix Representations","text":"using SparseArrays\nbasis = 1:12\n\n# Hamiltonian\nH = sum(Op(PAULI_X, i) * Op(PAULI_X, i+1) for i in 1:11)\nH_matrix = sparse(H, basis)","category":"page"},{"location":"guide/matrix_representation/#LinearMaps","page":"Matrix Representations","title":"LinearMaps","text":"","category":"section"},{"location":"guide/matrix_representation/","page":"Matrix Representations","title":"Matrix Representations","text":"using LinearMaps\nbasis = 1:20  # 2^20 ≈ 1 million dimensional space\n\nH = sum(Op(PAULI_X, i) * Op(PAULI_X, i+1) for i in 1:19)\nH_lm = LinearMap(H, basis)\n\n# Matrix-vector multiplication\nv = normalize!(rand(2^20))\nresult = H_lm * v","category":"page"},{"location":"guide/matrix_representation/#Working-with-Product-States","page":"Matrix Representations","title":"Working with Product States","text":"","category":"section"},{"location":"guide/matrix_representation/","page":"Matrix Representations","title":"Matrix Representations","text":"In some cases, it can be useful to work with product states directly without allocating on the full Hilbert space. For this, we provide limited funcionality to represent and manipulate product states via the apply function. Product states are represented as vectors of local state vectors, one for each site and applying and operator to this state is exactly applying the saved matrix of an operator to the local vector at the corresponding site. Hence, when using non-integer site identifiers, the order of basis elements has to be provided to apply to ensure correct mapping between site identifiers and local state vectors. Note, there are also corresponding in-place versions of apply provided, called apply!, to allow for efficient implementations.","category":"page"},{"location":"guide/matrix_representation/#Representing-States","page":"Matrix Representations","title":"Representing States","text":"","category":"section"},{"location":"guide/matrix_representation/","page":"Matrix Representations","title":"Matrix Representations","text":"# Three-site system, each site is a 2-level system\nstate = [\n    [1.0, 0.0],  # site 1\n    [1.0, 0.0],  # site 2\n    [0.0, 1.0]   # site 3\n]\n\n# Non-mutating\nnew_state = apply(Op(PAULI_X, 1), state)\n\n# Mutating (more efficient)\napply!(Op(PAULI_X, 1), state)\n\n# OpChain applies operators in sequence\nchain = Op(PAULI_X, 1) * Op(PAULI_Z, 2)\nresult = apply(chain, state)\n\n# generic site identifiers\napply(Op(PAULI_X, :site1), state, [:site1, :site2, :site3])","category":"page"},{"location":"guide/matrix_representation/","page":"Matrix Representations","title":"Matrix Representations","text":"apply only works for operations that preserve the product state structure. This means that sums of operators cannot be applied directly, as they generally create entanglement between sites and thus destroy the product state structure.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This page contains complete examples demonstrating various use cases of OperatorAlgebra.jl, creating hamiltonians and then using the created matrices to perform calculations.","category":"page"},{"location":"examples/#Quantum-Spin-Models","page":"Examples","title":"Quantum Spin Models","text":"","category":"section"},{"location":"examples/#Transverse-Field-Ising-Model","page":"Examples","title":"Transverse Field Ising Model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The Hamiltonian is: H = -J∑ᵢ σᵢᶻσᵢ₊₁ᶻ - h∑ᵢ σᵢˣ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OperatorAlgebra\nusing LinearAlgebra\n\nfunction tfim_hamiltonian(N::Int; J=1.0, h=0.5)\n    \"\"\"Transverse Field Ising Model\"\"\"\n    H = OpSum()\n    \n    # Ising interaction\n    H = sum(-J * Op(PAULI_Z, i) * Op(PAULI_Z, i+1) for i in 1:N-1)\n    \n    # Transverse field\n    H += sum(h * Op(PAULI_X, i) for i in 1:N)\n\n    return H\nend\n\n# Build and diagonalize\nN = 8\nH = tfim_hamiltonian(N, J=1.0, h=0.5)\nH_matrix = Array(H, 1:N)\neigenvalues = eigvals(H_matrix)\nground_energy = minimum(eigenvalues)\n\nprintln(\"Ground state energy: \", ground_energy)","category":"page"},{"location":"examples/#Heisenberg-Model","page":"Examples","title":"Heisenberg Model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The XXZ Heisenberg model: H = J∑ᵢ (σᵢˣσᵢ₊₁ˣ + σᵢʸσᵢ₊₁ʸ + Δσᵢᶻσᵢ₊₁ᶻ)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Arpack\nusing SparseArrays\n\nfunction heisenberg_hamiltonian(N::Int; J=1.0, Δ=1.0)\n    \"\"\"Heisenberg XXZ model\"\"\"\n    H = sum(\n        Op(PAULI_X, i) * Op(PAULI_X, i+1) +\n        Op(PAULI_Y, i) * Op(PAULI_Y, i+1) +\n        Δ * Op(PAULI_Z, i) * Op(PAULI_Z, i+1) \n    for i in 1:N-1)\n    \n    return H\nend\n\n# Isotropic case (Δ = 1)\nH_iso = heisenberg_hamiltonian(6, J=1.0, Δ=1.0)\nH_sparse = sparse(H_iso, 1:6)  # Convert to sparse matrix\n\n# Find extremal eigenvalues using Arpack\neigs(H_sparse)","category":"page"},{"location":"examples/#Tight-Binding-Model","page":"Examples","title":"Tight-Binding Model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Using creation and annihilation operators:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function tight_binding_chain(L::Int; t=1.0, V=1.0)\n    \"\"\"Tight-binding model on a chain\"\"\"\n\n    # Diagonal term: Nearest-neighbor potential\n    H_nn = sum(Op(OCC_PART, i) * Op(OCC_PART, i+1) for i in 1:L-1)\n\n    # Offdiagonal term: Hopping\n    H_hop = OpSum()\n    for i in 1:L-1\n        hop = Op(RAISE, i) * Op(LOWER, i+1)\n        H_hop += hop + hop'\n    end\n\n    return V * H_nn - t * H_hop\nend\n\n# Small tight-binding chain at the critical point\nL = 6\nH = tight_binding_chain(L, t=1.0, V=2.0)","category":"page"},{"location":"examples/#Tight-binding-chain-on-a-random-lattices","page":"Examples","title":"Tight-binding chain on a random lattices","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Graphs\n\ng = random_regular_graph(3, 10)  # 10 sites, degree 3\n\nfunction tightbinding_graph(g::Graph; t=1.0, V=1.0)\n    \"\"\"Tight-binding model on a graph\"\"\"\n    \n    # Diagonal term: Nearest-neighbor potential\n    H_nn = sum(Op(OCC_PART, u) * Op(OCC_PART, v) for (u, v) in edges(g))\n\n    # Offdiagonal term: Hopping\n    H_hop = OpSum()\n    for (u, v) in edges(g)\n        hop = Op(RAISE, u) * Op(LOWER, v)\n        H_hop += hop + hop'\n    end\n\n    return V * H_nn - t * H_hop\nend\nH = tightbinding_graph(g, t=1.0, V=2.0)\nH_sparse = sparse(H, vertices(g))","category":"page"},{"location":"examples/#Hubbard-Model","page":"Examples","title":"Hubbard Model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"function hubbard_chain(N::Int; t=1.0, U=2.0)\n    \"\"\"hard-core boson 1D Hubbard model\"\"\"\n\n    # Diagonal term: On-site interaction between spin species\n    H_int = OpSum()\n    for i in 1:N\n        H_int += Op(OCC_PART, (i, :up)) * Op(OCC_PART, (i, :down))\n    end\n\n    # Offdiagonal term: Hopping of both spin species\n    H_hop = OpSum()\n    for i in 1:N-1, species in (:up, :down)\n        H_hop += Op(RAISE, (i, species)) * Op(LOWER, (i+1, species))\n        H_hop += Op(LOWER, (i, species)) * Op(RAISE, (i+1, species))\n    end\n\n    return U * H_int - t * H_hop\nend\n\nH = hubbard_chain(6, t=1.0, U=2.0)\nbasis = [(i, s) for s in (:up, :down) for i in 1:6]\nH_matrix = sparse(H, basis)","category":"page"},{"location":"examples/#Majorana-SYK4-model","page":"Examples","title":"Majorana SYK4 model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# one-site Majorana operators for both Majorana species\nconst MAJORANA_1 = PAULI_X\nconst MAJORANA_2 = PAULI_Y\n\nfunction majorana_SYK4(N::Int; J=1.0)\n    \"\"\"Majorana SYK4 model Hamiltonian\"\"\"\n\n    # list of all different majorana species operators\n    majorana_ops = [[Op(MAJORANA_1, i) for i in 1:N÷2]; [Op(MAJORANA_2, i) for i in 1:N÷2]]\n\n    H = OpSum()\n    for i in 1:N, j in i+1:N, k in j+1:N, l in k+1:N\n        H += (majorana_ops[i] * majorana_ops[j] + majorana_ops[k] * majorana_ops[l])\n    end\n\n    return J * H\nend\n\nH_SYK4 = majorana_SYK4(12, J=1.0)\n# To ensure fermionic parity symmetry of the constructed operator, we can use the PAULI_Z matrix in place of the identity\nH = atsite(Matrix, H_SYK4, 1:12, id=PAULI_Z)","category":"page"},{"location":"guide/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"guide/getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"Since OperatorAlgebra.jl is a local package, you can add it in development mode:","category":"page"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.develop(path=\"/path/to/operator_algebra\")","category":"page"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"Or from the Julia REPL package mode (]):","category":"page"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"dev /path/to/operator_algebra","category":"page"},{"location":"guide/getting_started/#Basic-Concepts","page":"Getting Started","title":"Basic Concepts","text":"","category":"section"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"OperatorAlgebra.jl creates quantum operators acting on tensor product spaces. The main idea is to work with operators algebraically before converting them to a matrix representations.","category":"page"},{"location":"guide/getting_started/#Operators","page":"Getting Started","title":"Operators","text":"","category":"section"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"An operator in quantum mechanics is an abstract object living in a Hilbert space, however it can be cast into matrix representation by specifying a basis. In OperatorAlgebra.jl you will generally only need to define the one-site operators using the Op type. More complex operators can be built by combining these using addition and multiplication, which create OpSum and OpChain types respectively.","category":"page"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"Single-site operators (Op): Act on one site in a tensor product\nProducts (OpChain): Represent operator multiplication\nSums (OpSum): Represent linear combinations","category":"page"},{"location":"guide/getting_started/#Sites-and-Basis","page":"Getting Started","title":"Sites and Basis","text":"","category":"section"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"In a tensor product space, each \"site\" has its own local Hilbert space. For example, in a spin chain, each site might be a two-level system (spin-1/2).","category":"page"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"The basis is a vector of site identifiers that defines the structure of your system:","category":"page"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"basis = [1, 2, 3]  # Three sites labeled 1, 2, 3\n# or\nbasis = [\"A\", \"B\", \"C\"]  # Sites can have any identifiers","category":"page"},{"location":"guide/getting_started/#First-Steps","page":"Getting Started","title":"First Steps","text":"","category":"section"},{"location":"guide/getting_started/#Creating-Operators","page":"Getting Started","title":"Creating Operators","text":"","category":"section"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"We use the provided constant for the X-Pauli matrix to create a simple one-site operator at a site identified by 1. ","category":"page"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Create a Pauli X operator on site 1\nσx = Op(PAULI_X, 1)\n\n# Create a custom operator\nmy_matrix = [1.0 0.5; 0.5 -1.0]\ncustom_op = Op(my_matrix, 2)","category":"page"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"We can also combine operators to create more complex ones: The representation of the operators does not allocate any memory and is therefore very efficient.","category":"page"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Multiplication creates an OpChain\nproduct = σx * Op(PAULI_Y, 2)\n\n# Addition creates an OpSum\nsum_op = σx + Op(PAULI_Z, 2)\n\n# Can combine both\nH = σx + 0.5 * σx * Op(PAULI_Z, 2)","category":"page"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"While this package provides some application for the operators, the main purpose is to create and manipulate them algebraically before converting them to matrix representations. Hence, in most cases, you will want to convert them to a Matrix type before using them in calculations. Here, we convert the operator H to a sparse matrix representation, and to a linear map.","category":"page"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Define the system\nbasis = [1, 2]\n\n# Convert to sparse matrix\nH_matrix = sparse(H, basis)\n\n# For large systems, use LinearMaps\nusing LinearMaps\nH_lm = LinearMap(H, basis)","category":"page"},{"location":"guide/getting_started/#Working-with-States","page":"Getting Started","title":"Working with States","text":"","category":"section"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"This package also provides limited functionality to work with product states. A product state is represented as a vector of local state vectors, one for each site. The apply function can be used to apply operators to these product states. Note that apply only works for operators that preserve the product state structure (i.e., single-site operators and their products), and not for sums of operators.","category":"page"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Define a product state |↑↓⟩\nstate = [\n    [1.0, 0.0],  # |↑⟩ on site 1\n    [0.0, 1.0]   # |↓⟩ on site 2\n]\n\n# Apply an operator\nnew_state = apply(σx, state)","category":"page"},{"location":"guide/getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"guide/getting_started/","page":"Getting Started","title":"Getting Started","text":"Learn about Operator Types\nExplore Matrix Representations\nSee Examples","category":"page"},{"location":"#OperatorAlgebra.jl-Documentation","page":"Home","title":"OperatorAlgebra.jl Documentation","text":"","category":"section"},{"location":"#OperatorAlgebra.OperatorAlgebra","page":"Home","title":"OperatorAlgebra.OperatorAlgebra","text":"OperatorAlgebra\n\nA Julia package for working with quantum operators using an algebraic approach.\n\nOperatorAlgebra provides efficient representations and operations for quantum operators acting on tensor product spaces, with support for:\n\nFlexible operator types: Op, OpChain, OpSum\nTensor products: Kronecker operations with ⊗, kronpow, atsite\nMultiple backends: Sparse matrices, dense matrices, and matrix-free LinearMaps\nProduct state operations: Efficient apply for tensor product states\n\nMain Types\n\nAbstractOp: Base type for all operators\nOp: Single-site operator\nOpChain: Product of operators (A * B * C)\nOpSum: Sum of operators (A + B + C)\n\nKey Functions\n\napply, apply!: Apply operators to product states\natsite: Extend operator to full Hilbert space\nsparse: Convert to sparse matrix representation\nLinearMap: Create matrix-free representation\n⊗, kronpow: Tensor product operations\n\nPredefined Operators\n\nCommon quantum operators are exported as constants:\n\nPauli matrices: PAULI_X, PAULI_Y, PAULI_Z\nCreation/annihilation: RAISE, LOWER\nOccupation operators: OCC_PART, OCC_HOLE\n\nExample\n\nusing OperatorAlgebra\n\n# Define operators\nσx = Op(PAULI_X, 1)\nσz = Op(PAULI_Z, 2)\n\n# Build Hamiltonian\nH = σx + σz + 0.5 * σx * σz\n\n# Convert to matrix\nbasis = [1, 2]\nH_matrix = sparse(H, basis)\n\n# Apply to product state\nstate = [[1.0, 0.0], [1.0, 0.0]]\nnew_state = apply(σx, state)\n\nSee also: Op, OpChain, OpSum, apply, atsite\n\n\n\n\n\n","category":"module"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OperatorAlgebra.jl provides efficient representations and operations for quantum operators acting on tensor product spaces. The package is designed to provide a simple and flexible API to create and manipulate Hamiltonian operators and initialize them in a chosen Matrix representation.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Create Operators:\nAdd and multiply objects representing the abstract operators\nDefine objects representing your custom, abstract operators.\nUse a flexible description of your basis to convert to the matrix representation of the operators.\nMatrix representation:\nEasily convert your abstract operators into different Matrix representations.\nInitialize the matrix efficiently as sparse, dense or memory-less.","category":"page"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using OperatorAlgebra\n\n# Define Pauli operators on different sites\nσx = Op(PAULI_X, 1)\nσz = Op(PAULI_Z, 2)\n\n# Build a Hamiltonian\nH = σx + σz + 0.5 * σx * σz\n\n# Convert to sparse matrix\nbasis = [1, 2]\nH_matrix = sparse(H, basis)\n\n# Apply to a product state\nstate = [[1.0, 0.0], [1.0, 0.0]]  # |00⟩\nnew_state = apply(σx, state)       # |10⟩","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Since this is a local package, you can add it in development mode:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.develop(path=\"/path/to/operator_algebra\")","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"guide/getting_started.md\",\n    \"guide/operators.md\",\n    \"guide/matrix_representation.md\",\n    \"examples.md\",\n    \"api/types.md\",\n    \"api/operations.md\",\n    \"api/constants.md\",\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"api/operations/#Operations-Reference","page":"Operations","title":"Operations Reference","text":"","category":"section"},{"location":"api/operations/#Tensor-Products","page":"Operations","title":"Tensor Products","text":"","category":"section"},{"location":"api/operations/#OperatorAlgebra.:⊗","page":"Operations","title":"OperatorAlgebra.:⊗","text":"⊗(a, b)\n⊗(as...)\n\nUnicode alias for the Kronecker product (kron). Type \\otimes and press Tab.\n\nExamples\n\n# Tensor product of two matrices\nA = [1 0; 0 1]\nB = [0 1; 1 0]\nC = A ⊗ B  # Equivalent to kron(A, B)\n\n# Multiple tensor products\nD = A ⊗ B ⊗ C\n\nSee also: kron, kronpow\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#OperatorAlgebra.kronpow","page":"Operations","title":"OperatorAlgebra.kronpow","text":"kronpow(A, n::Integer)\n\nCompute the n-th Kronecker power of matrix A: A ⊗ A ⊗ ... ⊗ A (n times).\n\nUses a divide-and-conquer algorithm for efficient computation with large n.\n\nArguments\n\nA: Matrix to take Kronecker power of\nn: Non-negative integer power\n\nReturns\n\nThe n-th Kronecker power of A\n\nExamples\n\n# Identity on 2ⁿ-dimensional space\nI2_n = kronpow([1 0; 0 1], n)\n\n# Spin chain with all spins in |↑⟩ state\nup = [1, 0]\nchain_state = kronpow(up, n_sites)\n\nThrows\n\nArgumentError: If n is negative\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#OperatorAlgebra.atsite","page":"Operations","title":"OperatorAlgebra.atsite","text":"atsite(T, op::Op, basis)\natsite(T, op::Op, basis, dims, I=LinearAlgebra.I)\natsite(op::Op, basis)\n\nExtend a single-site operator to the full Hilbert space of a tensor product system.\n\nConstructs the full operator by inserting identity operators at all other sites: I ⊗ ... ⊗ I ⊗ op.mat ⊗ I ⊗ ... ⊗ I\n\nArguments\n\nT: Optional transformation function applied to op.mat (e.g., sparse)\nop::Op: Single-site operator to extend\nbasis: Vector of site identifiers defining the system\ndims: (Optional) Vector of local dimensions for each site\nI: (Optional) Identity matrix constructor, default is LinearAlgebra.I\n\nReturns\n\nThe full Hilbert space matrix representation\n\nExamples\n\n# Pauli X on site 2 of a 3-site system\nσx = Op(PAULI_X, 2)\nbasis = [1, 2, 3]\nσx_full = atsite(σx, basis)  # Returns I ⊗ PAULI_X ⊗ I\n\n# Convert to sparse matrix in the process\nσx_sparse = atsite(sparse, σx, basis)\n\n# For sites with different dimensions\ndims = [2, 3, 2]  # Site 2 has dimension 3\nop = Op(custom_3x3_matrix, 2)\nop_full = atsite(op, basis, dims)\n\nExtended Methods\n\natsite(os::OpSum, basis): Extends each term and sums\natsite(oc::OpChain, basis): Extends each operator and takes product\n\nSee also: Op, kronpow, sparse\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#Applying-Operators","page":"Operations","title":"Applying Operators","text":"","category":"section"},{"location":"api/operations/#OperatorAlgebra.apply","page":"Operations","title":"OperatorAlgebra.apply","text":"apply(op::AbstractOp, state)\napply(op::AbstractOp, state, basis)\n\nApply an operator to a product state (non-mutating version).\n\nThis function applies operators to product states represented as vectors of local state vectors. For Op, it applies the matrix to the corresponding site. For OpChain, it applies operators in reverse order (right-to-left as in matrix multiplication).\n\nArguments\n\nop: Operator to apply\nstate: Product state as vector of vectors, where state[i] is the state at site i\nbasis: (Optional) Vector of site identifiers if sites are not 1:N\n\nReturns\n\nA new product state after applying the operator\n\nExamples\n\n# Define a product state |↑↓⟩\nstate = [[1.0, 0.0], [0.0, 1.0]]\n\n# Apply Pauli X to first site\nσx = Op(PAULI_X, 1)\nnew_state = apply(σx, state)  # Results in |↓↑⟩\n\n# Apply operator chain\nchain = Op(PAULI_X, 1) * Op(PAULI_Z, 2)\nresult = apply(chain, state)\n\nNotes\n\nOnly works for product states. For general states, convert operator to matrix using sparse or LinearMap.\napply on OpSum throws an error since the result is not a product state.\n\nSee also: apply!, Op, OpChain, sparse\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#OperatorAlgebra.apply!","page":"Operations","title":"OperatorAlgebra.apply!","text":"apply!(op::AbstractOp, state)\napply!(op::AbstractOp, state, basis)\n\nApply an operator to a product state (mutating version).\n\nIn-place version of apply. Modifies the state vector directly.\n\nArguments\n\nop: Operator to apply\nstate: Product state to modify\nbasis: (Optional) Vector of site identifiers if sites are not 1:N\n\nReturns\n\nThe modified state\n\nExamples\n\nstate = [[1.0, 0.0], [0.0, 1.0]]\nσx = Op(PAULI_X, 1)\napply!(σx, state)  # state is now modified\n\nSee also: apply, Op, OpChain\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#Matrix-Representations","page":"Operations","title":"Matrix Representations","text":"","category":"section"},{"location":"api/operations/#Sparse-Matrices","page":"Operations","title":"Sparse Matrices","text":"","category":"section"},{"location":"api/operations/","page":"Operations","title":"Operations","text":"The sparse function from SparseArrays is extended to work with operators:","category":"page"},{"location":"api/operations/","page":"Operations","title":"Operations","text":"sparse(op::Op): Convert operator's matrix to sparse format\nsparse(op::OpSum): Convert all matrices in the sum to sparse format  \nsparse(op::OpChain): Convert all matrices in the chain to sparse format\nsparse(op::AbstractOp, basis): Convert to full Hilbert space sparse matrix","category":"page"},{"location":"api/operations/","page":"Operations","title":"Operations","text":"See the Matrix Representations guide for examples.","category":"page"},{"location":"api/operations/#LinearMaps","page":"Operations","title":"LinearMaps","text":"","category":"section"},{"location":"api/operations/","page":"Operations","title":"Operations","text":"The LinearMap function from LinearMaps.jl is extended to work with operators:","category":"page"},{"location":"api/operations/","page":"Operations","title":"Operations","text":"LinearMap(op::Op, basis): Create matrix-free representation\nLinearMap(os::OpSum, basis): Sum of LinearMaps\nLinearMap(oc::OpChain, basis): Product of LinearMaps","category":"page"},{"location":"api/operations/","page":"Operations","title":"Operations","text":"See the Matrix Representations guide for examples.","category":"page"},{"location":"api/operations/#Index","page":"Operations","title":"Index","text":"","category":"section"},{"location":"api/operations/","page":"Operations","title":"Operations","text":"Pages = [\"operations.md\"]","category":"page"},{"location":"guide/operators/#Operator-Types","page":"Operator Types","title":"Operator Types","text":"","category":"section"},{"location":"guide/operators/","page":"Operator Types","title":"Operator Types","text":"OperatorAlgebra.jl provides three main operator types, all subtypes of AbstractOp.","category":"page"},{"location":"guide/operators/#Op:-Single-Site-Operators","page":"Operator Types","title":"Op: Single-Site Operators","text":"","category":"section"},{"location":"guide/operators/","page":"Operator Types","title":"Operator Types","text":"Op represents an operator acting on a single site of a Hilbert space with local structure. Note that the dimension of the local Hilbert space is determined by the size of the matrix provided when creating the Op. Make sure, that when you have multiple operators acting on the same site, their local dimensions match.","category":"page"},{"location":"guide/operators/","page":"Operator Types","title":"Operator Types","text":"# Create an operator\nσx = Op(PAULI_X, 1)  # Pauli X on site 1\n\n# Custom matrix\nmy_op = Op([1.0 0.0; 0.0 -1.0], \"site_A\")","category":"page"},{"location":"guide/operators/","page":"Operator Types","title":"Operator Types","text":"On operators you can perform the standard arithmetic operations of a ring algebra: Addition, which is commutative, and multiplication, which in general is not. Furthermore, the inverse and identity elements (negative element and zero) for addition are well-defined, while for multiplication only the identity element (one element) is defined and there exists no inverse element. Furthermore, we define adjoint (hermitian conjugate) for convenience.","category":"page"},{"location":"guide/operators/","page":"Operator Types","title":"Operator Types","text":"σx1 = Op(PAULI_X, 1)\nσx2 = Op(PAULI_Y, 2)\n\n# Scalar multiplication\n2.0 * σx1\n\n# Adjoint (Hermitian conjugate)\nσx1'\n\n# Multiplication\nchain = σx1 * σx2  # Results in an OpChain object\n\n# Addition\nsummed = σx1 + σx2  # Results in OpSum","category":"page"},{"location":"guide/operators/","page":"Operator Types","title":"Operator Types","text":"Note that addition and multiplication of Op objects acting on the same site will result in a new Op with the combined matrix.","category":"page"},{"location":"guide/operators/","page":"Operator Types","title":"Operator Types","text":"The adjoint operation respects the commutative properties of sums of operators and chains of operators by applying the adjoint to each component appropriately and reversing the order of application in the case of chained operators.","category":"page"},{"location":"guide/operators/#Best-Practices","page":"Operator Types","title":"Best Practices","text":"","category":"section"},{"location":"guide/operators/","page":"Operator Types","title":"Operator Types","text":"Use the right type: Choose Op for single operators, let OpChain and OpSum be created automatically\nSparse matrices: For more efficient calculations, pass sparse matrices to the Op constructor. In some cases, specifically large local Hilbert spaces, this can significantly reduce memory usage and improve performance.\nType stability: Try to keep site identifiers and matrix types consistent within a calculation.","category":"page"},{"location":"guide/operators/#Examples","page":"Operator Types","title":"Examples","text":"","category":"section"},{"location":"guide/operators/#Building-a-simple-Hamiltonian","page":"Operator Types","title":"Building a simple Hamiltonian","text":"","category":"section"},{"location":"guide/operators/","page":"Operator Types","title":"Operator Types","text":"# Transverse field Ising: H = Σᵢ (XᵢXᵢ₊₁ + Zᵢ)\nN = 10\n\nH = sum(Op(PAULI_X, i) * Op(PAULI_X, i+1) for i in 1:N-1)\nH += sum(Op(PAULI_Z, i) for i in 1:N)","category":"page"},{"location":"guide/operators/#Operator-Algebra","page":"Operator Types","title":"Operator Algebra","text":"","category":"section"},{"location":"guide/operators/","page":"Operator Types","title":"Operator Types","text":"# Commutator [A, B] = AB - BA\nfunction commutator(A, B)\n    A * B - B * A\nend\n\n# Anti-commutator {A, B} = AB + BA\nfunction anticommutator(A, B)\n    A * B + B * A\nend\n\n# Verify Pauli matrix relations\nσx = Op(PAULI_X, 1)\nσy = Op(PAULI_Y, 1)\nσz = Op(PAULI_Z, 1)\n\ncommutator(σx, σy)  # [σx, σy] = 2i σz\nanticommutator(σx, σy)  # {σx, σy} = 0","category":"page"}]
}
